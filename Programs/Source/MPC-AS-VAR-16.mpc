from Compiler.types import sint, regint, Array, MemValue, cfix
from Compiler.types import compute_inverse, get_time
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else
import time


PORTNUM = 14000
MAX_NUM_CLIENTS = 1
n_rounds = 0  
n_threads = 1
number_inputs = 100000
number_variants = 1
number_bit_LR = 8
number_bits = 16 * number_variants
statistic_name = 'V'
communication_method = 'S'


if len(program.args) > 1:
    n_rounds = int(program.args[1])

if len(program.args) > 2:
    number_inputs = int(program.args[2])

def accept_client():
    client_socket_id = accept_client_connection(PORTNUM)
    last = regint.read_from_socket(client_socket_id)
    return client_socket_id, last

def close_connections(number_clients):
    @for_range(number_clients)
    def _(i):
        closeclientconnection(i)

def MAX_run_v2(number_clients, number_verified_clients):
    """Servers compute the MAX"""
    # receive data from clients
    received_matrix, x_matrix, active = sint.receive_from_client_MAX(number_inputs, number_bits, regint(0))
    
    # conduct the statistics calculation
    start_timer(1)
    x_matrix.iadd(received_matrix)
    x_sum_array = sint.Array(number_bits)
    x_sum_array[:] = x_matrix[0][:]
    @for_range(number_inputs - 1)
    def _(id):
        x_sum_array[:] += x_matrix[id + 1][:]
    x_sum_array_cint = x_sum_array.reveal()
    @for_range(number_bits)
    def _(bit_id):
        @if_(x_sum_array_cint[number_bits - 1 - bit_id]!= 0)
        def _():                                                           
            print_ln('%s clients, the result of MAX is %s.', number_clients, number_bits - 1 - bit_id)
            break_loop()       
        @if_(bit_id == number_bits - 1)
        def _():
            print_ln('The result of MAX is %s.', 0)                                                                          
    stop_timer(1)

def MIN_run(number_clients, number_verified_clients):
    """Servers compute the MAX"""
    # receive data from clients
    received_matrix, x_matrix, active = sint.receive_from_client_MAX(number_inputs, number_bits, regint(0))
    # conduct the statistics calculation
    start_timer(1)
    x_matrix.iadd(received_matrix)
    x_sum_array = sint.Array(number_bits)
    x_sum_array[:] = x_matrix[0][:]
    @for_range(number_inputs - 1)
    def _(id):
        x_sum_array[:] += x_matrix[id + 1][:]
    x_sum_array_cint = x_sum_array.reveal()
    @for_range(number_bits)
    def _(bit_id):
        @if_(x_sum_array_cint[bit_id] != 0)
        def _():                                                           
            print_ln('The result of MIN is %s.', bit_id - 1)
            break_loop()
        @if_(bit_id == number_bits - 1)
        def _():
            print_ln('The result of MIN is %s.', number_bits - 1)

    stop_timer(1)



def AND_run(number_clients, number_verified_clients):
    """Servers compute the AND"""
    received_array, x_array = sint.receive_from_client_AND(number_inputs, regint(0))
    
    # conduct the statistics calculation
    start_timer(1)
    @for_range(number_inputs)
    def _(i):
        x_array[i] += received_array[i]

    x_sum_array = sint.Array(1)
    x_sum_array[0] = x_array[0]
    @for_range(number_inputs - 1)
    def _(id):
        x_sum_array[0] += x_array[id + 1]
    x_sum_array_cint = x_sum_array[0].reveal()

    @if_e(x_sum_array_cint != 0)
    def _():                                                           
        print_ln('%s clients, the result of AND is 0.', number_clients)
    @else_
    def _():
        print_ln('%s clients, the result of AND is 1.', number_clients)                                                                               
    stop_timer(1)
    

def SUM_run(number_clients, number_verified_clients):
    """Servers compute the SUM"""
    # receive data from clients
    if communication_method == 'S':
        y_matrix = cint.Matrix(MAX_NUM_CLIENTS * number_inputs, number_bits)
        Y_array, r_matrix  = sint.receive_from_client_Single(number_inputs, number_bits, regint(0))
        start_timer(1)
        for input_id in range(number_inputs):
            ### perform binary decomposition
            Y_list = Y_array[input_id].bit_decompose(bit_length = number_bits)
            for bit_id in range(number_bits):
                y_matrix[input_id][bit_id] = Y_list[bit_id] + Y_list[bit_id] -1

    elif communication_method == 'M':
        y_matrix, r_matrix = sint.receive_from_client_Multiple(number_inputs, number_bits, regint(0))
        # server_running_time_start = get_time()
        start_timer(1)

    else:
        print_ln('unexpected communication method!')
    


    # verify clients' private values and obtain the authenticated shares of these values
    aggregate_result = sint.Array(1)
    middle_p = cint.Array(1) 
    middle_array = sint.Array(number_bits) 
    @for_range(number_bits)
    def _(bit_id):
        middle_array[bit_id] = y_matrix[0][bit_id]
    decision = 2**number_bits

    @for_range(number_clients)
    def _(client_id):
        @for_range(1, number_inputs)
        def _(input_id):
            flag = 1
            flag = (Y_array[input_id] < decision) * (Y_array[input_id] >= 0)
            
            @if_e(flag)
            def _():
                for bit_id in range(number_bits):
                    middle_array[bit_id] += y_matrix[input_id][bit_id] * r_matrix[input_id][bit_id] + 1
                number_verified_clients.write(number_verified_clients + 1)
            @else_
            def _():
                print_ln('The  %s th input of client %s is invalid!', input_id, client_id)
    # conduct the statistics calculation
    middle_p[0] = 1
    aggregate_result[0] = 0
    @for_range(number_bits)
    def _(bit_id):
        aggregate_result[0] += middle_array[bit_id] * middle_p[0]
        middle_p[0] = middle_p[0] + middle_p[0]
    
        
    aggregate_result = aggregate_result[0].reveal()
    print_ln('%s clients, %s valid inputs, the result of SUM is %s', number_clients, number_verified_clients, aggregate_result/2)
    stop_timer(1)   



def MEAN_run(number_clients, number_verified_clients):
    """Servers compute the MEAN"""
    # receive data from clients
    if communication_method == 'S':
        y_matrix = cint.Matrix(MAX_NUM_CLIENTS * number_inputs, number_bits)
        Y_array, r_matrix  = sint.receive_from_client_Single(number_inputs, number_bits, regint(0))
        start_timer(1)
        list_id = cint(0)
        for input_id in range(number_inputs):
            ### perform binary decomposition
            Y_list = Y_array[input_id].bit_decompose(bit_length = number_bits)
            for bit_id in range(number_bits):
                y_matrix[input_id][bit_id] = Y_list[bit_id] + Y_list[bit_id] -1

    elif communication_method == 'M':
        y_matrix, r_matrix = sint.receive_from_client_Multiple(number_inputs, number_bits, regint(0))
        # server_running_time_start = get_time()
        start_timer(1)

    else:
        print_ln('unexpected communication method!')
    


    # verify clients' private values and obtain the authenticated shares of these values
    aggregate_result = sint.Array(1)
    middle_p = cint.Array(1) 
    middle_array = sint.Array(number_bits) 
    @for_range(number_bits)
    def _(bit_id):
        middle_array[bit_id] = y_matrix[0][bit_id]
    decision = 2**number_bits

    @for_range(number_clients)
    def _(client_id):
        @for_range(1, number_inputs)
        def _(input_id):
            flag = 1
            flag = (Y_array[input_id] < decision) * (Y_array[input_id] >= 0)
            
            @if_e(flag)
            def _():
                for bit_id in range(number_bits):
                    middle_array[bit_id] += y_matrix[input_id][bit_id] * r_matrix[input_id][bit_id] + 1
                number_verified_clients.write(number_verified_clients + 1)
            @else_
            def _():
                print_ln('The  %s th input of client %s is invalid!', input_id, client_id)
    # conduct the statistics calculation
    middle_p[0] = 1
    aggregate_result[0] = 0
    @for_range(number_bits)
    def _(bit_id):
        aggregate_result[0] += middle_array[bit_id] * middle_p[0]
        middle_p[0] = middle_p[0] + middle_p[0]
    
        
    aggregate_result = aggregate_result[0].reveal()
    print_ln('%s clients, %s valid inputs, the result of MEAN is %s', number_clients, number_verified_clients, aggregate_result/2)
    print_ln('%s valid inputs, the result of MEAN can be calculated by the value of SUM and the number of valid inputs.', number_verified_clients)
    stop_timer(1)   



def VAR_run(number_clients, number_verified_clients):
    """Servers compute the VAR"""
    # receive data from clients
    if communication_method == 'S':
        y_matrix = cint.Matrix(MAX_NUM_CLIENTS * number_inputs, number_bits)
        Y_array, r_matrix = sint.receive_from_client_Single(number_inputs, number_bits, regint(0))
        start_timer(1)
        list_id = cint(0)
        for input_id in range(number_inputs):
            Y_list = Y_array[input_id].bit_decompose(bit_length = number_bits)
            for bit_id in range(number_bits):
                y_matrix[input_id][bit_id] = Y_list[bit_id] + Y_list[bit_id] - 1
        
    elif communication_method == 'M':
        y_matrix, r_matrix = sint.receive_from_client_Multiple(number_inputs, number_bits, regint(0))
        start_timer(1)

    else:
        print_ln('unexpected communication method!')
    
    # verify clients' private values and obtain the authenticated shares of these values
    aggregate_result = sint.Array(1)
    aggregate_result[0] = 0
    aggregate_result2 = sint.Array(1)
    aggregate_result2[0] = 0

    X_matrix = sint.Matrix(number_inputs,1)     
    X2_matrix = sint.Matrix(number_inputs,1)        

    decision = 2 ** number_bits

    @for_range(number_clients)
    def _(client_id):
        @for_range(number_inputs)
        def _(input_id):
            flag = 1
            flag = (Y_array[input_id] < decision) * (Y_array[input_id] >= 0) 
            
            @if_e(flag)
            def _():
                middle = 0
                middle_p = 1
                for bit_id in range(number_bits):
                    middle += middle_p * (y_matrix[input_id][bit_id] * r_matrix[input_id][bit_id] + 1)
                    middle_p = middle_p + middle_p
                X_matrix[number_verified_clients][0] = middle
                aggregate_result[0] += middle
                number_verified_clients.write(number_verified_clients + 1)
            @else_
            def _():
                print_ln('The  %s th input of client %s is invalid!', input_id, client_id)
    # conduct the statistics calculation
    X2_matrix = X_matrix.schur(X_matrix)
    @for_range(number_clients)
    def _(client_id):
        @for_range(number_inputs)
        def _(input_id):
            aggregate_result2[0] += X2_matrix[input_id][0]


    aggregate_result[0] = aggregate_result[0] / 2
    aggregate_result2[0] = aggregate_result2[0] / 4
    a1 = cfix(aggregate_result[0].reveal())
    a2 = cfix(aggregate_result2[0].reveal())
    print_ln('The sum of X is %s, the sum of X^2 is %s', a1, a2)
    print_ln('%s valid inputs, the result of VAR can be calculated by the value of the sum (i.e. X) and sum of squares (i.e. X^2).', number_verified_clients)

    stop_timer(1)




def LR_run_v2(number_clients, number_verified_clients):
    
    """Servers compute the LR""" 
    # receive data from clients
    if communication_method == 'S':
        y_matrix = cint.Matrix(MAX_NUM_CLIENTS * number_inputs, number_bits)
        # Y_array, r_matrix = sint.receive_from_client_VDAF_v3(number_inputs, number_bits, regint(0))  
        Y_array, r_matrix = sint.receive_from_client_Single(number_inputs, number_bits, regint(0))
        start_timer(1)
        @for_range(number_inputs)
        def _(input_id):
            Y_list = Y_array[input_id].bit_decompose(bit_length = number_bits)
            for bit_id in range(number_bits):
                y_matrix[input_id][bit_id] = Y_list[bit_id] + Y_list[bit_id] -1
    elif communication_method == 'M':
        y_matrix, r_matrix = sint.receive_from_client_Multiple(number_inputs, number_bits, regint(0))
        # server_running_time_start = time.time()
        start_timer(1)
    else:
        print_ln('unexpected communication method!')
    
    # verify clients' private values and obtain the authenticated shares of these values
    X = sint.Matrix(number_variants, number_inputs)
    Y = sint.Matrix(1, number_inputs) 
    decision = 2**number_bits
    number_verified_clients.write(0)
    @for_range(number_clients)
    def _(client_id):
        @for_range(number_inputs)
        def _(input_id):
            flag = 1
            flag = (Y_array[input_id] < decision) * (Y_array[input_id] >= 0)
            @if_(flag)
            def _():
                X[0][number_verified_clients] = 2
                x_array = Array(number_variants, sint)
                y_array = y_matrix[input_id]
                r_array = r_matrix[input_id]
                for i in range(number_variants):
                    x_array[i] = 0
                    mul_num = 1
                    for j in range(number_bit_LR):
                        x_array[i] += mul_num  * (y_array[i * number_bit_LR + j] * r_array[i * number_bit_LR + j] + 1)
                        mul_num = mul_num * 2
                for j in range(number_variants-1):
                    X[j+1][number_verified_clients] = x_array[j]
                Y[0][number_verified_clients] = x_array[number_variants-1]
                number_verified_clients.write(number_verified_clients + 1)

    # conduct the statistics calculation
    XTX = X.mul_trans(X)
    XTY = X.mul_trans(Y)

    XTX_cfix = cfix.Matrix(number_variants, number_variants)
    XTY_cfix = cfix.Matrix(number_variants, 1)


    @for_range(number_variants)
    def _(i):
        XTX_cfix[i][i] = XTX[i][i].reveal() / 4
        print_ln('XTX_cfix[%s][%s] = %s', i, i, XTX_cfix[i][i])        
        @for_range(number_variants - i - 1)
        def _(j):
            XTX_cfix[i][i + j + 1] = XTX[i][i + j + 1].reveal() / 4
            XTX_cfix[i + j + 1][i] = XTX_cfix[i][i + j + 1]
            print_ln('XTX[%s][%s] = %s', i, i + j + 1, XTX_cfix[i][i + j + 1])
            print_ln('XTX[%s][%s] = %s', i + j + 1, i, XTX_cfix[i + j + 1][i])

    

    
    @for_range(number_variants)
    def _(i):
        XTY_cfix[i][0] = XTY[i][0].reveal() / 4
        print_ln('XTY[%s][%s] = %s', i, 0, XTY_cfix[i][0])

    XTX_inverse = compute_inverse(XTX_cfix, number_variants)
    result = XTX_inverse * XTY_cfix
    print_ln('%s valid inputs, the result of LR can be calculated by the multiplication of the inverse of XTX and XTY.', number_verified_clients)

    
    stop_timer(1)

    



   


def FRQ_run(number_clients, number_verified_clients):
    """Servers compute the FRQ"""
    # receive data from clients
    if communication_method == 'S':
        y_matrix = cint.Matrix(MAX_NUM_CLIENTS * number_inputs, number_bits)

        Y_array, r_matrix = sint.receive_from_client_Single(number_inputs, number_bits, regint(0))
        start_timer(1)
        @for_range(number_inputs)
        def _(input_id):
            Y_list = Y_array[input_id].bit_decompose(bit_length = number_bits)
            for bit_id in range(number_bits):
                y_matrix[input_id][bit_id] = Y_list[bit_id] + Y_list[bit_id] -1
    elif communication_method == 'M':
        y_matrix, r_matrix = sint.receive_from_client_Multiple(number_inputs, number_bits, regint(0))
        start_timer(1)
    else:
        print_ln('unexpected communication method!')
    
    # verify clients' private values and obtain the authenticated shares of these values      
    x_matrix = sint.Matrix(MAX_NUM_CLIENTS * number_inputs, number_bits)
    tmp_x_array = sint.Array(number_bits)
    decision = 2**number_bits
    sum_flag_array = sint.Array(number_inputs)
    @for_range(number_clients)
    def _(client_id):
        @for_range(number_inputs)
        def _(input_id):
            flag = (Y_array[input_id] < decision) * (Y_array[input_id] >= 0)
            @if_e(flag)
            def _():
                middle_sum = sint(0)
                for bit_id in range(number_bits):
                    middle_x = (y_matrix[input_id][bit_id] * r_matrix[input_id][bit_id] + 1)
                    tmp_x_array[bit_id] = middle_x
                    middle_sum = middle_sum + middle_x
                sum_flag_array[number_verified_clients] = middle_sum
                x_matrix[number_verified_clients][:] = tmp_x_array[:]
                number_verified_clients.write(number_verified_clients + 1)
            @else_
            def _():
                print_ln('The input %s of client %s is malicious', input_id, client_id)
    sum_flag_array_reveal = sum_flag_array.reveal()
    
    # conduct the statistics calculation
    x_sum_array = sint.Array(number_bits)
    @for_range(number_verified_clients)
    def _(client_id):
        @if_e(sum_flag_array_reveal[client_id] == 2)
        def _():
            x_sum_array[:] += x_matrix[client_id][:]
        @else_
        def _():
            print_ln('The %s th input is invalid!', client_id + 1)

    x_sum_array_reveal = x_sum_array.reveal()
    @for_range(number_bits)
    def _(bit_id):
        print_ln('The %s th FRQ bit is %s.', bit_id, x_sum_array_reveal[bit_id]/2)
    stop_timer(1)

   
    

def main():
    """Listen in while loop for players to join a game.
    Once maxiumum reached or have notified that round finished, run computation and return result."""
    # Start listening for client socket connections
    listen_for_clients(PORTNUM)
    print_ln('Listening for client connections on base port %s', PORTNUM)

    def game_loop(_=None):
        print_ln('Starting a new round of the game.')

        client_sockets = Array(MAX_NUM_CLIENTS, regint)
        # Number of clients
        number_clients = MemValue(regint(0))
        # Number of verified clients
        number_verified_clients = MemValue(regint(0))
        # Keep track of received inputs
        seen = Array(MAX_NUM_CLIENTS, regint)
        seen.assign_all(0)

        # Loop round waiting for each client to connect
        
        @do_while
        def client_connections():
            client_id, last = accept_client()         # obtain the client ID from the client
            @if_(client_id >= MAX_NUM_CLIENTS)
            def _():
                print_ln('client id too high')
                crash()
            client_sockets[client_id] = client_id   
            seen[client_id] = 1                       # determine if the client has finished sending
            @if_(last == 1)                           # determine the number of participating clients
            def _():
                number_clients.write(client_id + 1)

            return (sum(seen) < number_clients) + (number_clients == 0)

        if statistic_name == 'S':
            SUM_run(number_clients, number_verified_clients)
        elif statistic_name == 'M':
            MAX_run_v2(number_clients, number_verified_clients)
        elif statistic_name == 'm':
            MIN_run(number_clients, number_verified_clients)
        elif statistic_name == 'F':
            FRQ_run(number_clients, number_verified_clients)
        elif statistic_name == 'L':
            LR_run_v2(number_clients, number_verified_clients)
        elif statistic_name == 'A':
            AND_run(number_clients, number_verified_clients)
        elif statistic_name == 'V':
            VAR_run(number_clients, number_verified_clients)
        elif statistic_name == 'E':
            MEAN_run(number_clients, number_verified_clients)
        else:
            return False
        close_connections(number_clients)

        return True

    if n_rounds > 0:
        print('run %d rounds' % n_rounds)
        for_range(n_rounds)(game_loop)
    else:
        print('run forever')
        do_while(game_loop)

main()


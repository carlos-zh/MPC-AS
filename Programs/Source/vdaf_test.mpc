
"""
  Our protocols about Malicious VDAF problem.
  1. securely compute the sum of private values from the clients.

  Demonstrate clients external to computing parties supplying input and receiving an authenticated result. Need .cpp file to do some work,
  such as bankers-bonus-client.cpp for client (and setup instructions).
  
  Wait for MAX_NUM_CLIENTS to join the game or client finish flag to be sent before calculating.

  Note each client connects in a single thread and so is potentially blocked.
  
  Each round / game will reset and so this runs indefinitiely.
"""

from Compiler.types import sint, regint, Array, MemValue
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else

PORTNUM = 14000       # clinet-server通信的端口
MAX_NUM_CLIENTS = 8   # client最多的数量
n_rounds = 0
n_threads = 2
number_bits = 8

if len(program.args) > 1:
    n_rounds = int(program.args[1])

if len(program.args) > 2:
    program.active = bool(int(program.args[2]))

def accept_client():
    client_socket_id = accept_client_connection(PORTNUM)      # accept_client_connection(): Accept client connection on specific port base, return client id.
    last = regint.read_from_socket(client_socket_id)          # read_from_socket(): 每个basic type都有的一个属性吧，用于Receive clear integer value(s) from client；client_id n size 三个参数，这里只用了第一个
    return client_socket_id, last

def close_connections(number_clients):
    @for_range(number_clients)
    def _(i):
        closeclientconnection(i)

def Z2N(value):
    """
    zero to negtive one
    """
    return 2 * value - 1

def N2Z(value):
    """
    negtive one to zero
    """
    return (value + 1) / 2


def server_to_client(number_bits):
    r_array = Array(number_bits, sint)   # {0,1}随机数数组
    R = Array(1, sint)                   # r_array表示成的p域的数

    tmp = sint.get_random_bit()
    r_array[0] = Z2N(tmp)
    R[0] = tmp

    @for_range(number_bits-1)
    def _(i):
        tmp = sint.get_random_bit()
        r_array[i+1] = Z2N(tmp)
        R[0] += 2 ** (i+1) * tmp

    return r_array, R[0]

def verify_client_inputs(client_values, number_bits):
    """
    暂时不用
    """
    flag = 1
    @for_range(number_bits)
    def _(i):
        @if_(client_values[i] ** 2 != 1)   # 平方不为1，则置flag=0
        def _():
            flag = 0
    return flag

def bin_to_dec(x_array, number_bits):
    x = Array(1, sint)
    x[0] = x_array[0]
    @for_range(number_bits-1)
    def _(i):
        x[0] += 2 ** (i+1) * x_array[i+1]
    return x[0]

def transform_valid_inputs(y_array, r_array, number_bits):
    """
    Input: y_list from client, <r_array> in server, the number of bits of the client value
    Output: decimal x
    """
    x_array = Array(number_bits, sint)

    for i in range(number_bits):
        x_array[i] = N2Z(y_array[i] * r_array[i])
    x = bin_to_dec(x_array, number_bits)

    return x

def server_local_computation(number_verified_clients, client_values):
    """
    Input: number_verified_clients, all the clients' value <X>
    Output: the local server summarize all the clients' value<X>
    """
    aggregate_result = Array(1, sint)
    
    aggregate_result[0] = client_values[0]
    
    @for_range(number_verified_clients - 1)
    def loop_body(i):
        aggregate_result[0] = aggregate_result[0] + client_values[i+1]

    return aggregate_result[0]

def main():
    """Listen in while loop for players to join a game.
    Once maxiumum reached or have notified that round finished, run computation and return result."""
    # Start listening for client socket connections
    listen_for_clients(PORTNUM)
    print_ln('Listening for client connections on base port %s', PORTNUM)


    def game_loop(_=None):
        print_ln('Starting a new round of the game.')

        # Clients socket id (integer).
        client_sockets = Array(MAX_NUM_CLIENTS, regint)           # regint类型的client_id的存储数组
        # Number of clients
        number_clients = MemValue(regint(0))
        # Number of verified clients
        number_verified_clients = MemValue(regint(0))
        # Keep track of received inputs
        seen = Array(MAX_NUM_CLIENTS, regint)
        seen.assign_all(0)                            # 初始化seen数组值全0
        # # Number of bits of a certain verified client's value
        # number_bits = MemValue(regint(8))

        # Loop round waiting for each client to connect
        @do_while
        def client_connections():
            client_id, last = accept_client()         # 从client获取id和对应client值
            @if_(client_id >= MAX_NUM_CLIENTS)
            def _():
                print_ln('client id too high')
                crash()
            client_sockets[client_id] = client_id     # regint类型的client_id数组
            # client_ids[client_id] = client_id       # sint类型的client_id数组
            seen[client_id] = 1                       # 设置seen=1，用于判断client是否发送完成
            @if_(last == 1)                           # 第一次client2server的通信，用于确定参与client的数量，完成client的设置
            def _():
                number_clients.write(client_id + 1)

            return (sum(seen) < number_clients) + (number_clients == 0)


        def type_run(t):
            
            ##################### 1. servers 与 clients的交互过程 #####################
            X_array = t.Array(MAX_NUM_CLIENTS)          # 所有client的十进制<X>的数组    @@@@@@@@@@@@@@@@@@@@@@@@@@@@此处的数组定义大小关注一下
            y_matrix = cint.Matrix(MAX_NUM_CLIENTS, number_bits)
            r_matrix = t.Matrix(MAX_NUM_CLIENTS, number_bits)

            @for_range_multithread(n_threads, 1, number_clients)
            def _(client_id):
                ################################(方案一，使用y_list)##############################
                # 1.1 servers生成<r_array>并把<R>传递给client_id的客户端, 再从client端接收y_array
                y_array, r_array = t.receive_from_client_VDAF(number_bits, client_id)
                @for_range(number_bits)
                def _(bit_id):
                    y_matrix[client_id][bit_id] = y_array[bit_id]
                    r_matrix[client_id][bit_id] = r_array[bit_id]

            @for_range(number_clients)
            def _(client_id):
                # 1.2 验证y，计算<x_array>并转成x 
                flag = MemValue(regint(1))
                @for_range(number_bits)
                def _(bit_id):
                    print_ln('y_array[%s]=%s', bit_id, y_matrix[client_id][bit_id])
                    @if_(y_matrix[client_id][bit_id] * y_matrix[client_id][bit_id] != 1)
                    def _():
                        print_ln('The %s th bit of the client %s is invalid!', bit_id, client_id)
                        flag.write(regint(0))
                @if_(flag)
                def _():
                    # 有效client输入数+1
                    number_verified_clients.write(number_verified_clients + 1)
                    # 将有效的client输入存入x_array数组
                    X_array[number_verified_clients - 1] = transform_valid_inputs(y_matrix[client_id], r_matrix[client_id], number_bits)
                ################################(方案一，使用y_list)##############################  

            aggregate_result = server_local_computation(number_verified_clients, X_array)
            print_ln('%s clients, %s valid clients, the result of VDAF is %s', number_clients, number_verified_clients, aggregate_result.reveal())

        print_ln('Connection built, waiting for communication and computation!!!!!!!!')
        type_run(sint)

        close_connections(number_clients)

        return True

    if n_rounds > 0:
        print('run %d rounds' % n_rounds)
        for_range(n_rounds)(game_loop)
    else:
        print('run forever')
        do_while(game_loop)

main()